using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using SharpDX.DirectWrite;

class CodeAnalyzer
{
    static void Main(string[] args)
    {
        string path = @"D:\Work\DotNet\DirectECS"; // Укажите ваш путь

        // Анализ кода
        AnalyzeCode(path);

        // Объединение Component-классов
        MergeComponentClasses(path);
    }

    static void AnalyzeCode(string directoryPath)
    {
        int classCount = 0;
        int structCount = 0;
        int lineCount = 0;
        int fileCount = 0;

        foreach (string file in Directory.EnumerateFiles(directoryPath, "*.cs", SearchOption.AllDirectories))
        {
            fileCount++;
            bool inMultilineComment = false;

            foreach (string line in File.ReadAllLines(file))
            {
                string trimmed = line.Trim();

                if (string.IsNullOrWhiteSpace(trimmed)) continue;
                if (trimmed.StartsWith("//")) continue;

                if (trimmed.StartsWith("/*"))
                {
                    inMultilineComment = true;
                }
                if (inMultilineComment)
                {
                    if (trimmed.EndsWith("*/"))
                    {
                        inMultilineComment = false;
                    }
                    continue;
                }

                lineCount++;

                if (trimmed.StartsWith("public class ") || trimmed.StartsWith("class ") ||
                    trimmed.StartsWith("internal class ") || trimmed.StartsWith("private class "))
                {
                    classCount++;
                }
                else if (trimmed.StartsWith("public struct ") || trimmed.StartsWith("struct ") ||
                         trimmed.StartsWith("internal struct ") || trimmed.StartsWith("private struct "))
                {
                    structCount++;
                }
            }
        }

        Console.WriteLine($"Проанализировано файлов: {fileCount}");
        Console.WriteLine($"Всего строк кода: {lineCount}");
        Console.WriteLine($"Классов: {classCount}");
        Console.WriteLine($"Структур: {structCount}");
    }

    static void MergeComponentClasses(string projectPath)
    {
        string outputFile = Path.Combine(projectPath, "AllComponents.cs");

        // Ищем классы и структуры компонентов (с Component в конце названия)
        Regex regex = new Regex(@"(class|struct)\s+\w+Component\b", RegexOptions.Compiled);

        StringBuilder combinedContent = new StringBuilder();
        combinedContent.AppendLine("// AUTO-GENERATED COMPONENT CLASSES");
        combinedContent.AppendLine($"// Generated at {DateTime.Now:yyyy-MM-dd HH:mm}");
        combinedContent.AppendLine("// DO NOT EDIT THIS FILE MANUALLY");
        combinedContent.AppendLine();

        try
        {
            int mergedCount = 0;

            foreach (string filePath in Directory.GetFiles(projectPath, "*.cs", SearchOption.AllDirectories))
            {
                string fileName = Path.GetFileName(filePath);

                // Пропускаем системные файлы и сам выходной файл
                if (fileName.Contains("System.cs") ||
                    fileName.Contains("AssemblyInfo.cs") ||
                    filePath.Equals(outputFile, StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                string fileContent = File.ReadAllText(filePath);

                if (regex.IsMatch(fileContent))
                {
                    string relativePath = GetRelativePath(projectPath, filePath);

                    combinedContent.AppendLine($"// ------ Source: {relativePath} ------");
                    combinedContent.AppendLine(fileContent);
                    combinedContent.AppendLine();
                    mergedCount++;

                    Console.WriteLine($"Found component: {relativePath}");
                }
            }

            if (mergedCount > 0)
            {
                File.WriteAllText(outputFile, combinedContent.ToString());
                Console.WriteLine($"\nSuccess! Merged {mergedCount} component classes into:\n{outputFile}");
            }
            else
            {
                Console.WriteLine("\nNo component classes found in project!");
                Console.WriteLine("Make sure your component classes have 'Component' suffix");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"\nError: {ex.Message}");
        }
    }

    static string GetRelativePath(string basePath, string fullPath)
    {
        if (!basePath.EndsWith(Path.DirectorySeparatorChar.ToString()))
            basePath += Path.DirectorySeparatorChar;

        Uri baseUri = new Uri(basePath);
        Uri fullUri = new Uri(fullPath);

        return Uri.UnescapeDataString(
            baseUri.MakeRelativeUri(fullUri).ToString().Replace('/', Path.DirectorySeparatorChar));
    }
}
